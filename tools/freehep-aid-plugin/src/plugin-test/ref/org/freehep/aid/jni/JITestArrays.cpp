// AID-GENERATED
// =========================================================================
// This class was generated by AID - Abstract Interface Definition          
// DO NOT MODIFY, but use the org.freehep.aid.Aid utility to regenerate it. 
// =========================================================================

#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>

#include "AID/JAIDRef.h"
#include "JITestArrays.h"

using namespace AIDTEST;


JITestArrays::JITestArrays(JNIEnv *env, jobject object)
        : JAIDRef(env, object) {
    jclass cls = env->GetObjectClass(ref);

    returnDoubleArrayOCADMethod = env->GetMethodID(cls, "returnDoubleArray", "()[D");
    if (returnDoubleArrayOCADMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "returnDoubleArray" << "()[D" << std::endl;
    }

    returnMultiDoubleArrayOCAADMethod = env->GetMethodID(cls, "returnMultiDoubleArray", "()[[D");
    if (returnMultiDoubleArrayOCAADMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "returnMultiDoubleArray" << "()[[D" << std::endl;
    }

    listObjectNamesOLjava_lang_StringEZCAAL_EMethod = env->GetMethodID(cls, "listObjectNames", "(Ljava/lang/String;Z)[[Lorg/freehep/aid/test/;");
    if (listObjectNamesOLjava_lang_StringEZCAAL_EMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "listObjectNames" << "(Ljava/lang/String;Z)[[Lorg/freehep/aid/test/;" << std::endl;
    }

    mkdirOAICVMethod = env->GetMethodID(cls, "mkdir", "([I)V");
    if (mkdirOAICVMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "mkdir" << "([I)V" << std::endl;
    }

    mkdirOAAICVMethod = env->GetMethodID(cls, "mkdir", "([[I)V");
    if (mkdirOAAICVMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "mkdir" << "([[I)V" << std::endl;
    }

    mkdirOAAAL_ECVMethod = env->GetMethodID(cls, "mkdir", "([[[Lorg/freehep/aid/test/;)V");
    if (mkdirOAAAL_ECVMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "mkdir" << "([[[Lorg/freehep/aid/test/;)V" << std::endl;
    }

    mkdirOAAL_ECVMethod = env->GetMethodID(cls, "mkdir", "([[Lorg/freehep/aid/test/;)V");
    if (mkdirOAAL_ECVMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "mkdir" << "([[Lorg/freehep/aid/test/;)V" << std::endl;
    }

    mkdir2OAAL_ECVMethod = env->GetMethodID(cls, "mkdir2", "([[Lorg/freehep/aid/test/;)V");
    if (mkdir2OAAL_ECVMethod == NULL) {
        std::cerr << "ITestArrays" << ": Could not find method: " << "mkdir2" << "([[Lorg/freehep/aid/test/;)V" << std::endl;
    }

}

JITestArrays::~JITestArrays() {
}

std::vector<double>  JITestArrays::returnDoubleArray() {
    std::vector<double>  result;
    // Call to Java
    jdoubleArray jniResult = (jdoubleArray)env->CallObjectMethod(ref, returnDoubleArrayOCADMethod);
    // convert double[] to vector<double>
    unsigned int len1 = env->GetArrayLength(jniResult);
    for (unsigned int i1=0; i1<len1; i1++) {
        jdouble d2;
        env->GetDoubleArrayRegion(jniResult, i1, 1, &d2);
        result.push_back(d2);
    }
    return result;
}

std::vector<std::vector<double> >  JITestArrays::returnMultiDoubleArray() {
    std::vector<std::vector<double> >  result;
    // Call to Java
    jobjectArray jniResult = (jobjectArray)env->CallObjectMethod(ref, returnMultiDoubleArrayOCAADMethod);
    // convert Objects[] into vector<objects>
    unsigned int len1 = env->GetArrayLength(jniResult);
    for (unsigned int i1=0; i1<len1; i1++) {
        jdoubleArray o2 = (jdoubleArray)env->GetObjectArrayElement(jniResult, i1);
        std::vector<double>  d2;
        // convert double[] to vector<double>
        unsigned int len2 = env->GetArrayLength(o2);
        for (unsigned int i2=0; i2<len2; i2++) {
            jdouble d3;
            env->GetDoubleArrayRegion(o2, i2, 1, &d3);
            d2.push_back(d3);
        }
        result.push_back(d2);
    }
    return result;
}

std::vector<std::string>  JITestArrays::listObjectNames(const std::string & path, bool recursive) {
    std::vector<std::string>  result;
    jstring jnipath;
    // converting string to String
    jnipath = env->NewStringUTF(path.c_str());
    jboolean jnirecursive;
    jnirecursive = recursive;
    // Call to Java
    jobjectArray jniResult = (jobjectArray)env->CallObjectMethod(ref, listObjectNamesOLjava_lang_StringEZCAAL_EMethod, jnipath, jnirecursive);
    // convert Objects[] into vector<objects>
    unsigned int len1 = env->GetArrayLength(jniResult);
    for (unsigned int i1=0; i1<len1; i1++) {
        jobject o2 = (jobject)env->GetObjectArrayElement(jniResult, i1);
        std::string d2;
// WARNING no conversion for []<String>[]
        result.push_back(d2);
    }
    return result;
}

bool JITestArrays::mkdir(std::vector<int>  dummy) {
    jintArray jnidummy;
    // convert vector<int> to int[]
    jnidummy = env->NewIntArray(dummy.size());
    for (int i1=0; i1<dummy.size(); i1++) {
        jint buf2 = dummy[i1];
        env->SetIntArrayRegion(jnidummy, i1, 1, &buf2);
    }
    // Call to Java
    env->CallVoidMethod(ref, mkdirOAICVMethod, jnidummy);
    jthrowable e = env->ExceptionOccurred();
    env->ExceptionClear();
    return (e != NULL) ? false : true;
}

bool JITestArrays::mkdir(std::vector<std::vector<int> >  dummy) {
    jobjectArray jnidummy;
    // convert vector<objects> into Objects[]
    jclass cls1 = env->FindClass("java.lang.Object");
    jnidummy = env->NewObjectArray(dummy.size(), cls1, NULL);
    for (int i1=0; i1<dummy.size(); i1++) {
        jintArray v2;
        // convert vector<int> to int[]
        v2 = env->NewIntArray(dummy[i1].size());
        for (int i2=0; i2<dummy[i1].size(); i2++) {
            jint buf3 = dummy[i1][i2];
            env->SetIntArrayRegion(v2, i2, 1, &buf3);
        }
        env->SetObjectArrayElement(jnidummy, i1, v2);
    }
    // Call to Java
    env->CallVoidMethod(ref, mkdirOAAICVMethod, jnidummy);
    jthrowable e = env->ExceptionOccurred();
    env->ExceptionClear();
    return (e != NULL) ? false : true;
}

bool JITestArrays::mkdir(std::vector<std::vector<std::string> >  dummy) {
    jobjectArray jnidummy;
    // convert vector<objects> into Objects[]
    jclass cls1 = env->FindClass("java.lang.Object");
    jnidummy = env->NewObjectArray(dummy.size(), cls1, NULL);
    for (int i1=0; i1<dummy.size(); i1++) {
        jobjectArray v2;
        // convert vector<objects> into Objects[]
        jclass cls2 = env->FindClass("Ldummypackagename.");
        v2 = env->NewObjectArray(dummy[i1].size(), cls2, NULL);
        for (int i2=0; i2<dummy[i1].size(); i2++) {
            jobject v3;
// WARNING no conversion for []<String>[][]
            env->SetObjectArrayElement(v2, i2, v3);
        }
        env->SetObjectArrayElement(jnidummy, i1, v2);
    }
    // Call to Java
    env->CallVoidMethod(ref, mkdirOAAAL_ECVMethod, jnidummy);
    jthrowable e = env->ExceptionOccurred();
    env->ExceptionClear();
    return (e != NULL) ? false : true;
}

bool JITestArrays::mkdir(std::vector<std::string *>  dummy) {
    jobjectArray jnidummy;
    // convert vector<objects> into Objects[]
    jclass cls1 = env->FindClass("Ldummypackagename.");
    jnidummy = env->NewObjectArray(dummy.size(), cls1, NULL);
    for (int i1=0; i1<dummy.size(); i1++) {
        jobject v2;
// WARNING no conversion for []<String*>[]
        env->SetObjectArrayElement(jnidummy, i1, v2);
    }
    // Call to Java
    env->CallVoidMethod(ref, mkdirOAAL_ECVMethod, jnidummy);
    jthrowable e = env->ExceptionOccurred();
    env->ExceptionClear();
    return (e != NULL) ? false : true;
}

bool JITestArrays::mkdir2(std::vector<std::string>  & dummy) {
    jobjectArray jnidummy;
    // convert vector<objects> into Objects[]
    jclass cls1 = env->FindClass("Ldummypackagename.");
    jnidummy = env->NewObjectArray(dummy.size(), cls1, NULL);
    for (int i1=0; i1<dummy.size(); i1++) {
        jobject v2;
// WARNING no conversion for []<String>&[]
        env->SetObjectArrayElement(jnidummy, i1, v2);
    }
    // Call to Java
    env->CallVoidMethod(ref, mkdir2OAAL_ECVMethod, jnidummy);
    jthrowable e = env->ExceptionOccurred();
    env->ExceptionClear();
    return (e != NULL) ? false : true;
}
