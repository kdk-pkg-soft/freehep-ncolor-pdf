// AID-GENERATED
// =========================================================================
// This class was generated by AID - Abstract Interface Definition          
// DO NOT MODIFY, but use the org.freehep.aid.Aid utility to regenerate it. 
// =========================================================================

#include <cstdlib>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include "AID/JAIDRef.h"
#include "JITestCollections.h"

using namespace AIDTEST;


JITestCollections::JITestCollections(JNIEnv *env, jobject object)
        : JAIDRef(env, object) {
    jclass cls = env->GetObjectClass(ref);

    mkdirOLjava_util_CollectionECVMethod = env->GetMethodID(cls, "mkdir", "(Ljava/util/Collection;)V");
    if (mkdirOLjava_util_CollectionECVMethod == NULL) {
        std::cerr << "ITestCollections" << ": Could not find method: " << "mkdir" << "(Ljava/util/Collection;)V" << std::endl;
    }

    convertOL_auto_ptrECL_auto_ptrEMethod = env->GetMethodID(cls, "convert", "(Lorg/freehep/aid/test/auto_ptr;)Lorg/freehep/aid/test/auto_ptr;");
    if (convertOL_auto_ptrECL_auto_ptrEMethod == NULL) {
        std::cerr << "ITestCollections" << ": Could not find method: " << "convert" << "(Lorg/freehep/aid/test/auto_ptr;)Lorg/freehep/aid/test/auto_ptr;" << std::endl;
    }

    parameterizedMethodOLjava_util_MapECLjava_util_CollectionEMethod = env->GetMethodID(cls, "parameterizedMethod", "(Ljava/util/Map;)Ljava/util/Collection;");
    if (parameterizedMethodOLjava_util_MapECLjava_util_CollectionEMethod == NULL) {
        std::cerr << "ITestCollections" << ": Could not find method: " << "parameterizedMethod" << "(Ljava/util/Map;)Ljava/util/Collection;" << std::endl;
    }

    convertFromMainOICCLjava_util_CollectionEMethod = env->GetMethodID(cls, "convertFromMain", "(IC)Ljava/util/Collection;");
    if (convertFromMainOICCLjava_util_CollectionEMethod == NULL) {
        std::cerr << "ITestCollections" << ": Could not find method: " << "convertFromMain" << "(IC)Ljava/util/Collection;" << std::endl;
    }

}

JITestCollections::~JITestCollections() {
}

bool JITestCollections::mkdir(std::vector<std::string>  dummy) {
    jobject jnidummy;
    // convert vector<object> to Collection<Object>
    jclass cls1 = env->FindClass("java.util.Vector");
    jmethodID constructor1 = env->GetMethodID(cls1, "<init>", "()V");
    jmethodID addMethod1 = env->GetMethodID(cls1, "add", "(Ljava/lang/Object;)Z");
    jnidummy = env->NewObject(cls1, constructor1);
    for (int i1=0; i1<dummy.size(); i1++) {
        jobject v2;
        // converting string to String
        v2 = env->NewStringUTF(dummy[i1].c_str());
        env->CallBooleanMethod(jnidummy, addMethod1, v2);
    }
    // Call to Java
    env->CallVoidMethod(ref, mkdirOLjava_util_CollectionECVMethod, jnidummy);
    jthrowable e = env->ExceptionOccurred();
    env->ExceptionClear();
    return (e != NULL) ? false : true;
}

std::auto_ptr<std::vector<std::string> >  JITestCollections::convert(std::auto_ptr<std::string>  name) {
    std::auto_ptr<std::vector<std::string> >  result;
    jobject jniname;
// WARNING no conversion for auto_ptr<String>
    // Call to Java
    jobject jniResult = (jobject)env->CallObjectMethod(ref, convertOL_auto_ptrECL_auto_ptrEMethod, jniname);
// WARNING no conversion for auto_ptr<[]<String>[]>
    return result;
}

std::vector<std::string>  JITestCollections::parameterizedMethod(std::map<std::string, std::string>  map) {
    std::vector<std::string>  result;
    jobject jnimap;
// WARNING no conversion for Map<String, String>
    // Call to Java
    jobject jniResult = (jobject)env->CallObjectMethod(ref, parameterizedMethodOLjava_util_MapECLjava_util_CollectionEMethod, jnimap);
    // convert Collection<Object> to vector<object>
    jclass collectionClass1 = env->GetObjectClass(jniResult);
    jmethodID iteratorMethod1 = env->GetMethodID(collectionClass1, "iterator", "()Ljava.util.Iterator;");
    jobject iterator1 = (jobject)env->CallObjectMethod(jniResult, iteratorMethod1);
    jclass iteratorClass1 = env->GetObjectClass(iterator1);
    jmethodID hasNextMethod1 = env->GetMethodID(iteratorClass1, "hasNext", "()Z");
    jmethodID nextMethod1 = env->GetMethodID(iteratorClass1, "next", "()Ljava.lang.Object;");
    while (env->CallBooleanMethod(iterator1, hasNextMethod1)) {
        jstring o2 = (jstring)env->CallObjectMethod(iterator1, nextMethod1);
        std::string d2;
        // converting String to string
        jboolean isCopy2;
        d2 = env->GetStringUTFChars(o2, &isCopy2);
        result.push_back(d2);
    }
    return result;
}

std::vector<std::string>  JITestCollections::convertFromMain(int argc, char * * arg) {
    std::vector<std::string>  result;
    jint jniargc;
    jniargc = argc;
    jchar jniarg;
    jniarg = arg;
    // Call to Java
    jobject jniResult = (jobject)env->CallObjectMethod(ref, convertFromMainOICCLjava_util_CollectionEMethod, jniargc, jniarg);
    // convert Collection<Object> to vector<object>
    jclass collectionClass1 = env->GetObjectClass(jniResult);
    jmethodID iteratorMethod1 = env->GetMethodID(collectionClass1, "iterator", "()Ljava.util.Iterator;");
    jobject iterator1 = (jobject)env->CallObjectMethod(jniResult, iteratorMethod1);
    jclass iteratorClass1 = env->GetObjectClass(iterator1);
    jmethodID hasNextMethod1 = env->GetMethodID(iteratorClass1, "hasNext", "()Z");
    jmethodID nextMethod1 = env->GetMethodID(iteratorClass1, "next", "()Ljava.lang.Object;");
    while (env->CallBooleanMethod(iterator1, hasNextMethod1)) {
        jstring o2 = (jstring)env->CallObjectMethod(iterator1, nextMethod1);
        std::string d2;
        // converting String to string
        jboolean isCopy2;
        d2 = env->GetStringUTFChars(o2, &isCopy2);
        result.push_back(d2);
    }
    return result;
}
