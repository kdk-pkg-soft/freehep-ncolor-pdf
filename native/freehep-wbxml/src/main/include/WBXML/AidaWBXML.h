// Generated by freehep-wbxml-plugin
#ifndef AIDAWBXML_INCLUDE
#define AIDAWBXML_INCLUDE 1

#include <string>
#include <sstream>
#include <map>

#include <WBXML/IAttributes.h>
#include <WBXML/ITagHandler.h>

namespace WBXML {

class AidaWBXML : public virtual ITagHandler {

public:

    virtual inline std::string getTag(unsigned int tag) {
        if (tag >= tags.size()) {
            std::stringstream s;
            s << "Unrecognized TagID: " << tag;
            return s.str();
        }
        return tags[tag];
    }
    
    virtual inline int getTag(std::string name) {
    	// FIXME, use new map
		std::map<unsigned int, std::string>::iterator i;   
		for (i = tags.begin(); i != tags.end(); i++) {
			if ((*i).second == name) return (*i).first;
		}
    	return -1;
    }

    virtual inline bool isTagEmpty(unsigned int tag) {
        if (tag >= tagIsEmpty.size()) return false;
        return tagIsEmpty[tag];
    }
    
    virtual inline std::string getAttribute(unsigned int tag) {
        if (tag >= attributes.size()) {
            std::stringstream s;
            s << "Unrecognized AttributeID: " << tag;
            return s.str();
        }
        return attributes[tag];
    }

    virtual inline int getAttribute(std::string name) {
    	// FIXME, use new map
		std::map<unsigned int, std::string>::iterator i;   
		for (i = attributes.begin(); i != attributes.end(); i++) {
			if ((*i).second == name) return (*i).first;
		}
    	return -1;
    }
    
    virtual inline IAttributes::Types getAttributeType(unsigned int tag) {
        if (tag >= attributeTypes.size()) return IAttributes::UNDEFINED;
        return attributeTypes[tag];
    }

    enum Tag {
        AIDA,			// 0 
        IMPLEMENTATION,			// 1 
        HISTOGRAM_1D,			// 2 
        HISTOGRAM_2D,			// 3 
        HISTOGRAM_3D,			// 4 
        AXIS,			// 5 
        BIN_BORDER,			// 6 
        STATISTICS,			// 7 
        STATISTIC,			// 8 
        DATA_1D,			// 9 
        BIN_1D,			// 10 
        DATA_2D,			// 11 
        BIN_2D,			// 12 
        DATA_3D,			// 13 
        BIN_3D,			// 14 
        TUPLE,			// 15 
        COLUMNS,			// 16 
        COLUMN,			// 17 
        ROWS,			// 18 
        ROW,			// 19 
        ENTRY,			// 20 
        ENTRY_ITUPLE,			// 21 
        CLOUD_1D,			// 22 
        CLOUD_2D,			// 23 
        CLOUD_3D,			// 24 
        ENTRIES_1D,			// 25 
        ENTRIES_2D,			// 26 
        ENTRIES_3D,			// 27 
        ENTRY_1D,			// 28 
        ENTRY_2D,			// 29 
        ENTRY_3D,			// 30 
        PROFILE_1D,			// 31 
        PROFILE_2D,			// 32 
        DATA_POINT_SET,			// 33 
        DATA_POINT,			// 34 
        MEASUREMENT,			// 35 
        ANNOTATION,			// 36 
        ITEM,			// 37 
        FUNCTION,			// 38 
        CODELET,			// 39 
        ARGUMENTS,			// 40 
        ARGUMENT,			// 41 
        RANGE,			// 42 
        PARAMETERS,			// 43 
        PARAMETER,			// 44 
        FIT_RESULT,			// 45 
        FITTED_PARAMETER,			// 46 
        COVARIANCE_MATRIX,			// 47 
        MATRIX_ELEMENT,			// 48 
        FIT_CONSTRAINT			// 49 
    };

    enum Attribute {
        VERSION,			// 0 
        XMLNS,			// 1 
        XMLNS_XSI,			// 2 
        XSI_SCHEMALOCATION,			// 3 
        VALUE_BOOLEAN,			// 4 
        VALUE_BYTE,			// 5 
        VALUE_CHAR,			// 6 
        VALUE_DOUBLE,			// 7 
        VALUE_FLOAT,			// 8 
        VALUE_INT,			// 9 
        VALUE_LONG,			// 10 
        VALUE_SHORT,			// 11 
        VALUE_STRING,			// 12 
        PACKAGE,			// 13 
        NAME,			// 14 
        TITLE,			// 15 
        PATH,			// 16 
        OPTIONS,			// 17 
        DIRECTION,			// 18 
        MIN,			// 19 
        MAX,			// 20 
        NUMBER_OF_BINS,			// 21 
        ENTRIES,			// 22 
        EQUIVALENT_BIN_ENTRIES,			// 23 
        MEAN,			// 24 
        RMS,			// 25 
        SKEWNESS,			// 26 
        BIN_NUM,			// 27 
        WEIGHTED_MEAN,			// 28 
        WEIGHTED_RMS,			// 29 
        HEIGHT,			// 30 
        ERROR,			// 31 
        ERROR_2,			// 32 
        BIN_NUM_X,			// 33 
        BIN_NUM_Y,			// 34 
        BIN_NUM_Z,			// 35 
        WEIGHTED_MEAN_X,			// 36 
        WEIGHTED_MEAN_Y,			// 37 
        WEIGHTED_MEAN_Z,			// 38 
        WEIGHTED_RMS_X,			// 39 
        WEIGHTED_RMS_Y,			// 40 
        WEIGHTED_RMS_Z,			// 41 
        TYPE,			// 42 
        MAX_ENTRIES,			// 43 
        LOWER_EDGE_X,			// 44 
        LOWER_EDGE_Y,			// 45 
        LOWER_EDGE_Z,			// 46 
        UPPER_EDGE_X,			// 47 
        UPPER_EDGE_Y,			// 48 
        UPPER_EDGE_Z,			// 49 
        CONVERSION_BINS,			// 50 
        CONVERSION_BINS_X,			// 51 
        CONVERSION_BINS_Y,			// 52 
        CONVERSION_BINS_Z,			// 53 
        CONVERSION_LOWER_EDGE,			// 54 
        CONVERSION_LOWER_EDGE_X,			// 55 
        CONVERSION_LOWER_EDGE_Y,			// 56 
        CONVERSION_LOWER_EDGE_Z,			// 57 
        CONVERSION_UPPER_EDGE,			// 58 
        CONVERSION_UPPER_EDGE_X,			// 59 
        CONVERSION_UPPER_EDGE_Y,			// 60 
        CONVERSION_UPPER_EDGE_Z,			// 61 
        VALUE_X,			// 62 
        VALUE_Y,			// 63 
        VALUE_Z,			// 64 
        WEIGHT,			// 65 
        DIMENSION,			// 66 
        ERROR_PLUS,			// 67 
        ERROR_MINUS,			// 68 
        KEY,			// 69 
        STICKY,			// 70 
        IS_NORMALIZED,			// 71 
        LABEL,			// 72 
        FIT_DIMENSION,			// 73 
        FIT_ENGINE_NAME,			// 74 
        FIT_METHOD_NAME,			// 75 
        FIT_IS_VALID,			// 76 
        FIT_QUALITY,			// 77 
        FIT_STATUS,			// 78 
        FIT_DEGREES_OF_FREEDOM,			// 79 
        FIT_DATA_DESCRIPTION,			// 80 
        FITTED_PARAMETER_NAME,			// 81 
        FITTED_PARAMETER_VALUE,			// 82 
        FITTED_PARAMETER_ERROR_PLUS,			// 83 
        FITTED_PARAMETER_ERROR_MINUS,			// 84 
        FITTED_PARAMETER_IS_FIXED,			// 85 
        FITTED_PARAMETER_STEP_SIZE,			// 86 
        FITTED_PARAMETER_LOWER_BOUND,			// 87 
        FITTED_PARAMETER_UPPER_BOUND,			// 88 
        MATRIX_ELEMENT_ROW,			// 89 
        MATRIX_ELEMENT_COLUMN,			// 90 
        MATRIX_ELEMENT_VALUE,			// 91 
        FIT_CONSTRAINT_VALUE			// 92 
    };

    AidaWBXML();

private:
    std::map<unsigned int, std::string> tags;
    std::map<unsigned int, bool> tagIsEmpty;
    std::map<unsigned int, std::string> attributes;
    std::map<unsigned int, IAttributes::Types> attributeTypes;

}; // class

} // namespace

#endif
